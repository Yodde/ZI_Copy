vec1 <- runif(100, min = 5, max = 10)
vec2 <- runif(100, min = 4, max = 12)
vec1
funkcjaSigmoi <- function(x) {     1 / (1 + exp(-x)) }
ls
ls()
vector1 <- runif(100, min = 5, max = 10)
vector2 <- runif(100, min = 0, max = 5)
vector2
install.packages('ISLR')
library(ISLR)
help(ISLR)
??ISLR
install.packages('neuralnet')
load(neuralnet)
library(neuralnet)
as.dataf(runif(50,0,100))
as.data.frame(runif(50,0,100))
sleep = as.data.frame(runif(100,2,12))
sleep = as.data.frame(runif(100,2,10))
study = as.data.frame(runif(100,0,8))
output = as.data.frame(runif(100,0,1))
outpu
output
output
ls
ls()
getwd()
library(neuralnet)
trainingInputSleep = as.data.frame(runif(100,min = 0,max=12))
trainingOutput = as.data.frame(runif(100,min = 2,max = 5))
trainingOutput(20)
trainingOutput[1-20]
head(trainingOutput,n=10)
trainingDataFirst = cbind(trainingInputSleep,tr)
trainingDataFirst = cbind(trainingInputSleep,trainingOutput)
colnames(trainingDataFirst) = c("Input","Output")
head(trainingDataFirst,n=10)
net.sqrt = neuralnet(Output~Input,trainingDataFirst,hidden = 2,threshold = 0.01)
print(net.sqrt)
plot(net.sqrt)
net.sqrt = neuralnet(Output~Input,trainingDataFirst,hidden = 10,threshold = 0.01)
plot(net.sqrt)
clearPushBack
rm(ls())
  rm(list =ls())
ls
ls()
sleepVec <- runif(100, min = 0, max = 12)
study <- runif(100, min = 0, max = 10)
neural.function.sigmoid <- function(z) {     1 / (1 + exp(-z)) }
neural.function.sigmoid(10)
neural.function.sigmoid(0.2)
neural.function.sigmoid(0.01)
neural.function.sigmoid(0.2)
neural.function.sigmoid(0.9)
neural.function.sigmoid(2)
data.sleep.and.study = cbind(sleepVec,runif(1,0,1),study,runif(1,0,1))
head(data.sleep.and.study,n=10)
rm(data.sleep.and.study)
head(sleepVec,n=10)
sleepWeight = runif(1,0,1)
studyWeight = runif(1,0,1)
sleepwe
studyWeight
head(sleepVec,5)
head(sleepVec*3,5)
sum(head(sleepVec*3,5))
sum(head(sleepVec*3,5))
sum(sleepVec,study)
sleepVec+study
sleepVec*sleepWeight + study*studyWeight
sleepVec[1]
sleepw
sleepWeight
studyWeight
study[1]
test.multiply.by.3 <- function(x) {     x * 3 }
test.multiply.by.3(slee)
test.multiply.by.3(sleepVec)
neural.function.sigmoid
neural.function.sigmoid(study)
neural.function.activation.function = function(vec1, w1, vec2, w2) {     z <- vec1 * w1 + vec2 * w2     neural.function.sigmoid(z) }
output <- neural.function.activation.function(sleepVec,sleepWeight,study,studyWeight)
output
sleepWeight
sleepWeight = runif(1,0,1)
sleepWeight
output <- neural.function.activation.function(sleepVec,sleepWeight,study,studyWeight)
output
ls
ls()
ls()
output
inputVector <- c(1-100)
inputVector
inputVector <- c(1:100))
inputVector <- c(1:100)
inputVector
outputVector <- inputVector*2
outpu
outputVector 
b1 <- runif(1,0,1)
b1
neural.function.activation.function
nerural.funct
neural.
neural.function.sigmoid
neural.function.sigmoid <- function(z, b) {     1 / (1 + exp(-z * b))  }
neural.fun
neural.function.sigmoid(inputVector,b1)
neural.activation.function.simple <- function(value, weight) {     value * weight }
neural.activation.function.simple(inputVector,b1)
b1*100
learning.weight <- 0.2
learning.factor <- 0.2
learn.network <- function(input, output, beta, learning.rate) {     estimated <- neural.activation.function.simple(input, beta)   newBeta <- beta - (learning.rate * (estimated - output)*input) }
simpleFunc <- function(x) {     x <- x*2 }
a = 1
a
simpleFunc(a)
a
a = simpleFunc
a = simpleFunc(a)
a
a = 2
a = simpleFunc(a)
a
learn.network(inputVector,outputVector,b1,learning.factor)
b1
b1 = learn.network(inputVector,outputVector,b1,learning.factor)
b1
ls()
neural.function.activation.function
rm(neural.function.activation.function)
rm(test.multiply.by.3)
lear
learning.factor
learning.weight
rem(learning.weight)
rm(learning.weight)
neural.activation.function.simple
learn.network
learn.network.step.2 <- function(input, output, beta, learning.rate, repeated, values.to.take = 2) {     range.min <- repeated * values.to.take - (values.to.take - 1)     range.max <- repeated * values.to.take     estimated <- neural.activation.function.simple(input[range.min:range.max], beta)     beta - (sum(estimated - output[range.min:range.max]) / values.to.take * sum(input[range.min:range.max]) / values.to.take) * learning.rate }
bbb = learn.network.step.2(inputVector,output,b1,learning.factor,1)
bbb
neural.activation.function.simple(inputVector[1:2],b1)
inputVector[1:2]
v = inputVector[1:2]
v
learn.network.step.2 <- function(input, output, beta, learning.rate, repeated, values.to.take = 2) {     range.min <- repeated * values.to.take - (values.to.take - 1)     range.max <- repeated * values.to.take     invec <- input[range.min:range.max]     outvec <- output[range.min:range.max]     estimated <- neural.activation.function.simple(invec, beta)     beta - (sum(estimated - outvec) / values.to.take * sum(invec) / values.to.take) * learning.rate }
bbb = learn.network.step.2(inputVector,output,b1,learning.factor,1)
bbb
bbb = learn.network.step.2(inputVector,output,b1,learning.factor,1,2)
bbb
learn.n
learn
learn.network.step.2
neural.activation.function.simple(v,b1)
v
neural
neural.activation.function.simple
b1
b1 = myVec <- runif(1, min = 0, max = 1)
b1
bbb = learn.network.step.2(inputVector,output,b1,learning.factor,1)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb
bbb
bbb
bbb
bbb
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,1)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,2)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,3)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,4)
bbb
neural.activation.function.simple
lea
learn.network.step.2
learn.network.step.2 <- function(input, output, beta, learning.rate, repeated, values.to.take = 2) {     range.min <- repeated * values.to.take - (values.to.take - 1)     range.max <- repeated * values.to.take     invec <- input[range.min:range.max]     outvec <- output[range.min:range.max]     estimated <- neural.activation.function.simple(invec, beta)     beta - ((sum(estimated - outvec) / values.to.take) * (sum(invec) / values.to.take)) * learning.rate }
learning.factor
bbb = learn.network.step.2(inputVector,output,b1,learning.factor,3)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,4)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,5)
bbb
bbb = learn.network.step.2(inputVector,output,bbb,learning.factor,6)
bbb
learn.network.step.2 <- function(input, output, beta, learning.rate, repeated, values.to.take = 2) {     range.max <- repeated * values.to.take     range.min <- range.max - (values.to.take - 1)     invec <- input[range.min:range.max]     outvec <- output[range.min:range.max]     estimated <- neural.activation.function.simple(invec, beta)     (beta - (((sum(estimated - outvec) / values.to.take) * (sum(invec) / values.to.take)) * learning.rate)) }
input
inputVector
outputVector
bbb = learn.network.step.2(inputVector,outputVector,b1,learning.factor,1)
bbb
bbb = learn.network.step.2(inputVector,outputVector,bbb,learning.factor,2)
bbb
bbb = learn.network.step.2(inputVector,outputVector,bbb,learning.factor,3)
bbb
bbb = learn.network.step.2(inputVector,outputVector,bbb,learning.factor,4)
bbb
bbb = learn.network.step.2(inputVector,outputVector,bbb,learning.factor,5)
bbb
